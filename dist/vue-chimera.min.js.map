{"version":3,"file":"vue-chimera.min.js","sources":["../src/utils.js","../node_modules/p-debounce/index.js","../src/Resource.js","../src/NullResource.js","../src/VueChimera.js","../src/mixin.js","../src/cache/MemoryCache.js","../src/index.js","../src/NuxtPlugin.js","../src/cache/StorageCache.js"],"sourcesContent":["import Axios from 'axios'\n\nexport function isPlainObject (value) {\n  return typeof value === 'object' && Object.prototype.toString(value) === '[object Object]'\n}\n\nexport function remove (arr, item) {\n  if (arr.length) {\n    const index = arr.indexOf(item)\n    if (index > -1) {\n      return arr.splice(index, 1)\n    }\n  }\n}\n\nexport const hasKey = (obj, key) => key in (obj || {})\n\nexport function mergeExistingKeys (...obj) {\n  let o = Object.assign(...obj)\n  return Object.keys(obj[0]).reduce((carry, item) => {\n    carry[item] = o[item]\n    return carry\n  }, {})\n}\n\nexport function createAxios (config) {\n  if (config instanceof Axios) {\n    return config\n  }\n  // Support nuxt axios\n  if (config && typeof config.$request === 'function') {\n    return config\n  }\n  if (isPlainObject(config)) {\n    return Axios.create(config)\n  }\n  if (typeof config === 'function') {\n    if (typeof config.request === 'function') return config\n    let axios = config()\n    if (axios instanceof Axios) return axios\n  }\n  return Axios\n}\n\nexport function noop () {}\n\nexport function noopReturn (arg) { return arg }\n","'use strict';\nmodule.exports = (fn, wait, opts) => {\n\tif (!Number.isFinite(wait)) {\n\t\tthrow new TypeError('Expected `wait` to be a finite number');\n\t}\n\n\topts = opts || {};\n\n\tlet leadingVal;\n\tlet timer;\n\tlet resolveList = [];\n\n\treturn function () {\n\t\tconst ctx = this;\n\t\tconst args = arguments;\n\n\t\treturn new Promise(resolve => {\n\t\t\tconst runImmediately = opts.leading && !timer;\n\n\t\t\tclearTimeout(timer);\n\n\t\t\ttimer = setTimeout(() => {\n\t\t\t\ttimer = null;\n\n\t\t\t\tconst res = opts.leading ? leadingVal : fn.apply(ctx, args);\n\n\t\t\t\tfor (resolve of resolveList) {\n\t\t\t\t\tresolve(res);\n\t\t\t\t}\n\n\t\t\t\tresolveList = [];\n\t\t\t}, wait);\n\n\t\t\tif (runImmediately) {\n\t\t\t\tleadingVal = fn.apply(ctx, args);\n\t\t\t\tresolve(leadingVal);\n\t\t\t} else {\n\t\t\t\tresolveList.push(resolve);\n\t\t\t}\n\t\t});\n\t};\n};\n","import Axios from 'axios'\nimport { isPlainObject, noopReturn } from './utils'\nimport pDebounce from 'p-debounce'\nconst { CancelToken } = Axios\n\nexport const EVENT_SUCCESS = 'success'\nexport const EVENT_ERROR = 'error'\nexport const EVENT_CANCEL = 'cancel'\nexport const EVENT_LOADING = 'loading'\nexport const EVENT_TIMEOUT = 'timeout'\n\nconst INITIAL_DATA = {\n  loading: false,\n  status: null,\n  data: null,\n  headers: null,\n  error: null,\n  lastLoaded: null\n}\n\nexport default class Resource {\n  constructor (options, initial) {\n    if (typeof options === 'string') options = { url: options }\n\n    let {\n      autoFetch,\n      prefetch,\n      cache,\n      debounce,\n      transformer,\n      axios,\n      key,\n      interval,\n      ...request\n    } = options\n\n    request.method = (request.method || 'get').toLowerCase()\n\n    if (typeof autoFetch === 'string') {\n      this.autoFetch = autoFetch.toLowerCase() === request.method\n    } else {\n      this.autoFetch = Boolean(autoFetch)\n    }\n\n    this.key = key\n    this.prefetch = typeof prefetch === 'boolean' ? prefetch : this.autoFetch\n    this.cache = cache\n    this.axios = axios\n    this.fetchDebounced = pDebounce(this.fetch.bind(this), debounce, { leading: true })\n\n    // Set Transformers\n    this.setTransformer(transformer)\n\n    if (request.data) {\n      console.warn('[Chimera]: Do not use \"params\" key inside resource options, use data instead')\n    }\n\n    if (request.method !== 'get') {\n      request.data = request.params\n      delete request.params\n    }\n\n    this.request = {\n      ...request,\n      cancelToken: new CancelToken(c => {\n        this._canceler = c\n      })\n    }\n\n    this._listeners = {}\n    this.prefetched = false\n\n    // Set Events\n    if (isPlainObject(options.on)) {\n      for (let key in options.on) {\n        this.on(key, options.on[key])\n      }\n    }\n\n    initial && Object.assign(this, INITIAL_DATA, initial)\n  }\n\n  setTransformer (transformer) {\n    if (typeof transformer === 'function') {\n      this.responseTransformer = transformer\n      this.errorTransformer = transformer\n    } else if (isPlainObject('object')) {\n      const { response, error } = transformer\n      this.responseTransformer = response || noopReturn\n      this.errorTransformer = error || noopReturn\n    } else {\n      this.responseTransformer = noopReturn\n      this.errorTransformer = noopReturn\n    }\n  }\n\n  on (event, handler) {\n    let listeners = this._listeners[event] || []\n    listeners.push(handler)\n    this._listeners[event] = listeners\n    return this\n  }\n\n  emit (event) {\n    (this._listeners[event] || []).forEach(handler => {\n      handler(this, event)\n    })\n  }\n\n  fetch (force, extraParams, extraOptions) {\n    return new Promise((resolve, reject) => {\n\n      if (this.cache && !force) {\n        let cacheValue = this.getCache()\n        if (cacheValue) {\n          this.setByResponse(cacheValue)\n          return resolve(cacheValue)\n        }\n      }\n\n      this.loading = true\n      this.emit(EVENT_LOADING)\n\n      // Merge extra options\n      let { request } = this\n      if (isPlainObject(extraOptions)) {\n        request = Object.assign({}, request, isPlainObject(extraOptions) ? {} : {})\n      }\n      // Merge extra params\n      if (isPlainObject(extraParams)) {\n        const paramKey = request.method === 'get' ? 'params' : 'data'\n        request[paramKey] = Object.assign(request[paramKey], extraParams)\n      }\n\n      // Finally make request\n      this.axios.request(request).then(res => {\n        this.setByResponse(res)\n        this.setCache(res)\n        this.emit(EVENT_SUCCESS)\n        resolve(res)\n      }).catch(err => {\n        this.setByResponse(err.response)\n        if (Axios.isCancel(err)) {\n          this.emit(EVENT_CANCEL)\n        } else if (err.message && !err.response && err.message.indexOf('timeout') !== -1) {\n          this.emit(EVENT_TIMEOUT)\n        } else {\n          this.emit(EVENT_ERROR)\n        }\n\n        reject(err)\n      }).finally(() => {\n        this.loading = false\n      })\n    })\n  }\n\n  reload (force) {\n    return this.fetchDebounced(force)\n  }\n\n  send (params, options) {\n    return this.fetchDebounced(true, params, options)\n  }\n\n  cancel (unload) {\n    if (unload) this.data = null\n    if (typeof this._canceler === 'function') this._canceler()\n    this.request.cancelToken = new CancelToken(c => { this._canceler = c })\n  }\n\n  getCacheKey () {\n    if (this.key) return this.key\n    return (typeof window !== 'undefined' && typeof btoa !== 'undefined'\n      ? window.btoa\n      : x => x)(this.request.url +\n      this.request.params +\n      this.request.data +\n      this.request.method)\n  }\n\n  getCache () {\n    return this.cache ? this.cache.getItem(this.getCacheKey()) : undefined\n  }\n\n  setCache (value) {\n    this.cache && this.cache.setItem(this.getCacheKey(), value)\n  }\n\n  deleteCache () {\n    this.cache && this.cache.removeItem(this.getCacheKey())\n  }\n\n  setByResponse (res) {\n    res = res || {}\n    const isSuccessful = String(res.status).charAt(0) === '2'\n    this.status = res.status\n    this.headers = res.headers || {}\n    this.lastLoaded = new Date()\n    this.data = isSuccessful ? this.responseTransformer(res.data, this) : null\n    this.error = !isSuccessful ? this.errorTransformer(res.data, this) : null\n  }\n\n  startInterval (ms) {\n    if (typeof ms !== 'number') throw new Error('[Chimera]: interval should be number')\n    if (typeof process !== 'undefined' && process.server) return\n\n    this._interval = ms\n    this.stopInterval()\n    this._interval_id = setInterval(() => this.reload(true), this._interval)\n    this.looping = true\n  }\n\n  stopInterval () {\n    if (this._interval_id) {\n      clearInterval(this._interval_id)\n      this.looping = false\n      this._interval_id = null\n      this._interval = false\n    }\n  }\n\n  toObj () {\n    const json = {}\n    Object.keys(INITIAL_DATA).forEach(key => {\n      json[key] = this[key]\n    })\n    return json\n  }\n\n  toString () {\n    return JSON.stringify(this.toObj())\n  }\n\n  get params () {\n    return this.request.method === 'get' ? this.request.params : this.request.data\n  }\n\n  get url () {\n    return this.request.url\n  }\n\n  get method () {\n    return this.request.method\n  }\n}\n","import Resource from './Resource'\n\nexport default class NullResource extends Resource {\n  fetch (force) {\n    return Promise.reject(new Error('Null Resource'))\n  }\n\n  cancel () {}\n}\n","import Resource from './Resource'\nimport NullResource from './NullResource'\nimport { createAxios, hasKey, isPlainObject } from './utils'\n\n// unregister events\nexport default class VueChimera {\n  constructor (vm, { ...resources }, { deep, ...options }) {\n    this._vm = vm\n    this._watchers = []\n\n    this._axios = options.axios = createAxios(options.axios)\n    this._options = options\n    this._deep = deep\n    const watchOption = {\n      immediate: true,\n      deep: this._deep,\n      sync: true\n    }\n\n    for (let key in resources) {\n      if (key.charAt(0) === '$') continue\n\n      let r = resources[key]\n      if (typeof r === 'function') {\n        this._watchers.push([\n          () => r.call(this._vm),\n          (t, f) => this.updateResource(key, t, f),\n          watchOption\n        ])\n      } else {\n        resources[key] = this.resourceFrom(r)\n        resources[key].reload()\n      }\n    }\n\n    Object.defineProperty(resources, '$cancelAll', { value: this.cancelAll.bind(this) })\n    Object.defineProperty(resources, '$axios', { get: () => this._axios })\n    Object.defineProperty(resources, '$loading', { get () { return !!Object.values(this).find(el => !!el.loading) } })\n    this._resources = resources\n\n    // Init computeds\n    const vmOptions = this._vm.$options\n    const computeds = vmOptions.computed = vmOptions.computed || {}\n    Object.keys(resources).forEach(key => {\n      if (hasKey(computeds, key) || hasKey(vmOptions.props, key) || hasKey(vmOptions.methods, key)) return\n      computeds[key] = () => this._resources[key]\n    })\n  }\n\n  init () {\n    this._watchers = this._watchers.map(w => this._vm.$watch(...w))\n  }\n\n  updateResource (key, newValue, oldValue) {\n    const oldResource = this._resources[key]\n    const newResource = this.resourceFrom(newValue, oldValue && oldValue.keepData ? oldResource.toObj() : null)\n\n    if (oldValue && oldResource) {\n      oldResource.stopInterval()\n      newResource.lastLoaded = oldResource.lastLoaded\n    }\n\n    if (newValue.interval) {\n      newResource.startInterval(newValue.interval)\n    }\n\n    if (newResource.autoFetch) newResource.reload()\n    this._vm.$set(this._resources, key, newResource)\n  }\n\n  resourceFrom (value, initial) {\n    if (value == null) return new NullResource()\n    if (typeof value === 'string') value = { url: value }\n\n    if (isPlainObject(value.on)) {\n      Object.entries(value.on).forEach(([event, handler]) => {\n        if (typeof handler === 'function') {\n          handler = handler.bind(this._vm)\n        }\n        if (typeof handler === 'string') handler = this._vm[handler]\n        value.on[event] = handler\n      })\n    }\n\n    const baseOptions = Object.create(this._options)\n    return new Resource(Object.assign(baseOptions, value), initial)\n  }\n\n  cancelAll () {\n    Object.values(this._resources).forEach(r => {\n      r.cancel()\n    })\n  }\n\n  destroy () {\n    const vm = this._vm\n\n    this.cancelAll()\n    delete vm._chimera\n  }\n}\n","import VueChimera from './VueChimera'\nimport { isPlainObject } from './utils'\n\nexport default (options = {}) => ({\n  beforeCreate () {\n    const vmOptions = this.$options\n    let _chimera\n\n    // Stop if instance doesn't have chimera or already initialized\n    if (!vmOptions.chimera || vmOptions._chimera) return\n\n    if (typeof vmOptions.chimera === 'function') {\n      // Initialize with function\n      vmOptions.chimera = vmOptions.chimera.call(this)\n    }\n\n    if (vmOptions.chimera instanceof VueChimera) {\n      _chimera = vmOptions.chimera\n    } else if (isPlainObject(vmOptions.chimera)) {\n      const { $options, ...resources } = vmOptions.chimera\n      _chimera = new VueChimera(this, resources, { ...options, ...$options })\n    }\n\n    // Nuxtjs prefetch\n    const NUXT = typeof process !== 'undefined' && process.server && this.$ssrContext\n      ? this.$ssrContext.nuxt\n      : (typeof window !== 'undefined' ? window.__NUXT__ : null)\n    if (_chimera && NUXT && NUXT.chimera) {\n      try {\n        if (this.$router) {\n          let matched = this.$router.match(this.$router.currentRoute.fullPath);\n          (matched ? matched.matched : []).forEach((m, i) => {\n            let nuxtChimera = NUXT.chimera[i]\n            if (nuxtChimera) {\n              Object.keys(_chimera.resources).forEach(key => {\n                let localResource = _chimera.resources[key]\n                let ssrResource = nuxtChimera[key]\n                if (localResource && ssrResource && ssrResource._data) {\n                  [\n                    '_data', '_status', '_headers', 'ssrPrefetched',\n                    '_lastLoaded'].forEach(key => {\n                    localResource[key] = ssrResource[key]\n                  })\n                }\n              })\n            }\n          })\n          // if (process.client) {\n          //   delete NUXT.chimera\n          // }\n        }\n      } catch (e) {}\n    }\n    this._chimera = _chimera\n    Object.defineProperty(this, '$chimera', {\n      get: () => _chimera._resources\n    })\n  },\n\n  data () {\n    if (!this._chimera) return {}\n    return {\n      $chimera: this._chimera._resources\n    }\n  },\n\n  created () {\n    if (!this._chimera) return\n    this._chimera.init()\n  }\n\n  // mounted () {\n  //   if (this._chimera) {\n  //     this._chimera.updateReactiveResources()\n  //     for (let r in this._chimera.resources) {\n  //       let resource = this._chimera.resources[r]\n  //       if (resource.prefetch && (!resource.ssrPrefetched || resource.ssrPrefetch === 'override')) {\n  //         resource.reload()\n  //       }\n  //     }\n  //   }\n  // },\n})\n","export class MemoryCache {\n  constructor (expiration) {\n    this.expiration = expiration || 1000 * 60\n    this._store = {}\n  }\n\n  /**\n     *\n     * @param key         Key for the cache\n     * @param value       Value for cache persistence\n     * @param expiration  Expiration time in milliseconds\n     */\n  setItem (key, value, expiration) {\n    this._store[key] = {\n      expiration: Date.now() + (expiration || this.expiration),\n      value\n    }\n  }\n\n  /**\n     * If Cache exists return the Parsed Value, If Not returns {null}\n     *\n     * @param key\n     */\n  getItem (key) {\n    let item = this._store[key]\n\n    if (item && item.value && Date.now() <= item.expiration) {\n      return item.value\n    }\n\n    console.log('sss')\n\n    this.removeItem(key)\n    return null\n  }\n\n  removeItem (key) {\n    delete this._store[key]\n  }\n\n  keys () {\n    return Object.keys(this._store)\n  }\n\n  all () {\n    return this.keys().reduce((obj, str) => {\n      obj[str] = this._store.getItem(str)\n      return obj\n    }, {})\n  }\n\n  length () {\n    return this.keys().length\n  }\n\n  clearCache () {\n    this._store = {}\n  }\n}\n","import mixin from './mixin'\nimport NuxtPlugin from './NuxtPlugin'\n\nconst plugin = {\n\n  options: {\n    axios: null,\n    cache: null,\n    debounce: 50,\n    deep: true,\n    keepData: true,\n    autoFetch: 'get', // false, true, '%METHOD%',\n    prefetch: null,\n    prefetchTimeout: 4000,\n    transformer: null\n  },\n\n  install (Vue, options = {}) {\n    Object.keys(options).forEach(key => {\n      if (key in this.options) {\n        this.options[key] = options[key]\n      }\n    })\n\n    Vue.mixin(mixin(this.options))\n  },\n\n  NuxtPlugin\n\n}\n\n// Auto-install\nlet GlobalVue = null\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue\n}\n\nif (GlobalVue) {\n  GlobalVue.use(plugin, plugin.options)\n}\n\nexport default plugin\n\nexport * from './Resource'\nexport { StorageCache } from './cache/StorageCache'\nexport { MemoryCache } from './cache/MemoryCache'\n","import Resource from './Resource'\n\nexport default function () {\n  this.options = this.options || {}\n  const baseOptions = this.options\n\n  return function ({ beforeNuxtRender, isDev, $axios }) {\n    if (!beforeNuxtRender) { return }\n\n    const cancelTokens = []\n    async function prefetchAsyncData ({ Components, nuxtState }) {\n      nuxtState.chimera = nuxtState.chimera || {}\n\n      for (let i = 0, len = Components.length; i < len; i++) {\n        let component = Components[i]\n        let chimera = component.options ? component.options.chimera : null\n\n        if (typeof chimera === 'function') {\n          // Append @Nuxtjs/axios to component (maybe needed by constructor)\n          if ($axios && !component.$axios) component.$axios = $axios\n          chimera = chimera.bind(component)()\n        }\n\n        if (!chimera) { continue }\n\n        const nuxtChimera = {}\n        const { $options, ...resources } = chimera\n        const options = Object.assign({}, baseOptions, $options)\n        if (!options.axios) options.axios = $axios\n\n        for (let key in resources) {\n          let resource = resources[key]\n          if (resource && typeof resource !== 'function') {\n            resource = resource && resource._data ? resource : Resource.from(resource, options)\n            cancelTokens.push(resource.cancel.bind(resource))\n            if (!resource.prefetch || !resource.ssrPrefetch) continue\n            try {\n              isDev && console.log('  Prefetching: ' + resource.requestConfig.url) // eslint-disable-line no-console\n              let response = await resource.execute()\n              resource._data = response.data\n            } catch (err) {\n              isDev && console.error(err.message) // eslint-disable-line no-console\n            }\n            resource.ssrPrefetched = true\n            resources[key] = nuxtChimera[key] = resource\n          }\n        }\n        if (Object.keys(nuxtChimera).length) {\n          nuxtState.chimera[i] = nuxtChimera\n        }\n      }\n    }\n\n    beforeNuxtRender((...args) => {\n      return new Promise((resolve, reject) => {\n        prefetchAsyncData(...args).then(resolve).catch(reject)\n        setTimeout(reject, baseOptions.ssrPrefetchTimeout, new Error('  SSR Prefetch Timeout.'))\n      }).catch(err => {\n        for (let cancel of cancelTokens) if (typeof cancel === 'function') cancel()\n        isDev && console.error(err.message) // eslint-disable-line no-console\n      })\n    })\n  }\n}\n","import { MemoryCache } from './MemoryCache'\n\nexport class StorageCache extends MemoryCache {\n  constructor (key, expiration, sessionStorage = false) {\n    super(expiration)\n    this.key = key\n\n    const storage = sessionStorage ? 'sessionStorage' : 'localStorage'\n    if (typeof window === 'undefined' || !window[storage]) {\n      throw Error(`StorageCache: ${storage} is not available.`)\n    } else {\n      this.storage = window[storage]\n    }\n\n    try {\n      this._store = JSON.parse(this.storage.getItem(key)) || {}\n    } catch (e) {\n      this.clearCache()\n      this._store = {}\n    }\n  }\n\n  setItem (key, value, expiration) {\n    super.setItem(key, value, expiration)\n    this.storage.setItem(this.key, JSON.stringify(this._store))\n  }\n\n  clearCache () {\n    this.storage.removeItem(this.key)\n  }\n}\n"],"names":["isPlainObject","value","Object","prototype","toString","hasKey","obj","key","noopReturn","arg","fn","wait","opts","Number","isFinite","TypeError","leadingVal","timer","resolveList","ctx","this","args","arguments","Promise","resolve","runImmediately","leading","clearTimeout","setTimeout","res","apply","push","CancelToken","Axios","EVENT_SUCCESS","EVENT_ERROR","EVENT_CANCEL","EVENT_LOADING","EVENT_TIMEOUT","INITIAL_DATA","loading","status","data","headers","error","lastLoaded","Resource","constructor","options","initial","url","autoFetch","prefetch","cache","debounce","transformer","axios","interval","request","method","toLowerCase","Boolean","fetchDebounced","pDebounce","fetch","bind","setTransformer","console","warn","params","cancelToken","c","_canceler","_listeners","prefetched","on","assign","responseTransformer","errorTransformer","response","event","handler","listeners","emit","forEach","force","extraParams","extraOptions","reject","cacheValue","getCache","setByResponse","paramKey","then","setCache","catch","err","isCancel","message","indexOf","finally","reload","send","cancel","unload","getCacheKey","window","btoa","x","getItem","undefined","setItem","deleteCache","removeItem","isSuccessful","String","charAt","Date","startInterval","ms","Error","process","server","_interval","stopInterval","_interval_id","setInterval","looping","clearInterval","toObj","json","keys","JSON","stringify","NullResource","VueChimera","vm","resources","deep","_vm","_watchers","_axios","config","$request","create","createAxios","_options","_deep","watchOption","immediate","sync","r","call","t","f","updateResource","resourceFrom","defineProperty","cancelAll","get","values","find","el","_resources","vmOptions","$options","computeds","computed","props","methods","init","map","w","$watch","newValue","oldValue","oldResource","newResource","keepData","$set","entries","baseOptions","destroy","_chimera","beforeCreate","chimera","NUXT","$ssrContext","nuxt","__NUXT__","$router","matched","match","currentRoute","fullPath","m","i","nuxtChimera","localResource","ssrResource","_data","e","$chimera","created","MemoryCache","expiration","_store","now","item","log","all","reduce","str","length","clearCache","plugin","prefetchTimeout","install","Vue","mixin","NuxtPlugin","beforeNuxtRender","isDev","$axios","cancelTokens","Components","nuxtState","len","component","resource","from","ssrPrefetch","requestConfig","execute","ssrPrefetched","prefetchAsyncData","ssrPrefetchTimeout","GlobalVue","global","use","sessionStorage","storage","parse"],"mappings":"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"}