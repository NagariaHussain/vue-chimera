{"version":3,"file":"vue-chimera.min.js","sources":["../node_modules/p-debounce/index.js","../src/events.js","../src/utils.js","../src/http/axiosAdapter.js","../src/Endpoint.js","../src/NullEndpoint.js","../src/VueChimera.js","../src/mixin.js","../src/components/ChimeraEndpoint.vue","../node_modules/vue-runtime-helpers/dist/normalize-component.mjs","../src/cache/MemoryCache.js","../src/index.js","../src/cache/StorageCache.js"],"sourcesContent":["'use strict';\nmodule.exports = (fn, wait, opts) => {\n\tif (!Number.isFinite(wait)) {\n\t\tthrow new TypeError('Expected `wait` to be a finite number');\n\t}\n\n\topts = opts || {};\n\n\tlet leadingVal;\n\tlet timer;\n\tlet resolveList = [];\n\n\treturn function () {\n\t\tconst ctx = this;\n\t\tconst args = arguments;\n\n\t\treturn new Promise(resolve => {\n\t\t\tconst runImmediately = opts.leading && !timer;\n\n\t\t\tclearTimeout(timer);\n\n\t\t\ttimer = setTimeout(() => {\n\t\t\t\ttimer = null;\n\n\t\t\t\tconst res = opts.leading ? leadingVal : fn.apply(ctx, args);\n\n\t\t\t\tfor (resolve of resolveList) {\n\t\t\t\t\tresolve(res);\n\t\t\t\t}\n\n\t\t\t\tresolveList = [];\n\t\t\t}, wait);\n\n\t\t\tif (runImmediately) {\n\t\t\t\tleadingVal = fn.apply(ctx, args);\n\t\t\t\tresolve(leadingVal);\n\t\t\t} else {\n\t\t\t\tresolveList.push(resolve);\n\t\t\t}\n\t\t});\n\t};\n};\n","export const SUCCESS = 'success'\nexport const ERROR = 'error'\nexport const CANCEL = 'cancel'\nexport const LOADING = 'loading'\nexport const TIMEOUT = 'timeout'\n","export function isPlainObject (value) {\n  return typeof value === 'object' && value && Object.prototype.toString(value) === '[object Object]'\n}\n\nexport function mergeExistingKeys (...obj) {\n  let o = Object.assign({}, ...obj)\n  return Object.keys(obj[0]).reduce((carry, item) => {\n    carry[item] = o[item]\n    return carry\n  }, {})\n}\n\nexport const hasKey = (obj, key) => key in (obj || {})\n\nexport function getServerContext (contextString) {\n  try {\n    let context = window\n    const keys = contextString.split('.')\n    keys.forEach(key => {\n      context = context[key]\n    })\n    return context\n  } catch (e) {}\n  return null\n}\n\nexport function noopReturn (arg) { return arg }\n\nexport function warn (arg, ...args) {\n  // eslint-disable-next-line no-console\n  console.warn('[Chimera]: ' + arg, ...args)\n}\n","import Axios, { CancelToken } from 'axios'\nimport { isPlainObject } from '../utils'\n\nfunction createAxios (config) {\n  if (typeof config === 'function') {\n    if (typeof config.request === 'function') return config\n    return config()\n  }\n  if (isPlainObject(config)) {\n    return Axios.create(config)\n  }\n  return Axios\n}\n\nexport default {\n  request (request, endpoint) {\n    const axios = endpoint.axios ? createAxios(endpoint.axios) : Axios\n    return axios.request({\n      ...request,\n      cancelToken: new CancelToken(c => { endpoint._canceler = c })\n    })\n  },\n  cancel (endpoint) {\n    if (typeof endpoint._canceler === 'function') endpoint._canceler()\n    endpoint._canceler = null\n  },\n  isCancelError (err) {\n    return Axios.isCancel(err)\n  }\n}\n","import pDebounce from 'p-debounce'\nimport * as events from './events'\nimport { isPlainObject, mergeExistingKeys, noopReturn, warn } from './utils'\nimport axiosAdapter from './http/axiosAdapter'\n\nconst INITIAL_RESPONSE = {\n  status: null,\n  data: null,\n  headers: null,\n  error: null,\n  lastLoaded: null\n}\n\nconst INITIAL_REQUEST = {\n  url: null,\n  baseURL: null,\n  method: 'get',\n  params: null,\n  timeout: 0,\n  headers: null\n}\n\nexport default class Endpoint {\n  constructor (opts, initial) {\n    if (typeof opts === 'string') opts = { url: opts, key: opts }\n\n    if (!opts) {\n      warn('Invalid options', opts)\n      throw new Error('[Chimera]: invalid options')\n    }\n\n    let {\n      debounce,\n      transformer,\n      interval,\n      on: listeners,\n      ...options\n    } = opts\n\n    options.method = (options.method || 'get').toLowerCase()\n\n    this.fetchDebounced = debounce !== false\n      ? pDebounce(this.fetch.bind(this), debounce || 50, { leading: true })\n      : this.fetch\n\n    // Set Transformers\n    this.setTransformer(transformer)\n\n    this.prefetched = false\n    this.loading = false\n\n    // Set Events\n    this.listeners = {}\n    if (isPlainObject(listeners)) {\n      for (const key in listeners) {\n        this.on(key, listeners[key])\n      }\n    }\n\n    Object.assign(this, options)\n\n    // Handle type on auto\n    if (typeof this.auto === 'string') {\n      this.auto = this.auto.toLowerCase() === this.method\n    } else {\n      this.auto = Boolean(this.auto)\n    }\n    this.prefetch = this.prefetch != null ? this.prefetch : this.auto\n\n    Object.assign(this, INITIAL_RESPONSE, initial || {})\n\n    this.http = axiosAdapter\n\n    interval && this.startInterval(interval)\n  }\n\n  setTransformer (transformer) {\n    if (typeof transformer === 'function') {\n      this.responseTransformer = transformer\n      this.errorTransformer = transformer\n    } else if (isPlainObject(transformer)) {\n      const { response, error } = transformer\n      this.responseTransformer = response || noopReturn\n      this.errorTransformer = error || noopReturn\n    } else {\n      this.responseTransformer = noopReturn\n      this.errorTransformer = noopReturn\n    }\n  }\n\n  on (event, handler) {\n    let listeners = this.listeners[event] || []\n    listeners.push(handler)\n    this.listeners[event] = listeners\n    return this\n  }\n\n  emit (event) {\n    (this.listeners[event] || []).forEach(handler => {\n      handler(this, event)\n    })\n  }\n\n  fetch (force, extraOptions) {\n    return new Promise((resolve, reject) => {\n      if (this.cache && !force) {\n        let cacheValue = this.getCache()\n        if (cacheValue) {\n          this.setResponse(cacheValue)\n          return resolve(cacheValue)\n        }\n      }\n\n      this.loading = true\n      this.emit(events.LOADING)\n\n      let { request } = this\n      if (isPlainObject(extraOptions)) {\n        // Merge extra options\n        if (extraOptions.params) {\n          extraOptions.params = Object.assign({}, request.params, extraOptions.params)\n        }\n        request = Object.assign({}, request, extraOptions)\n      }\n\n      // Finally make request\n      this.http.request(request, this).then(res => {\n        this.loading = false\n        this.setResponse(res)\n        this.setCache(res)\n        this.emit(events.SUCCESS)\n        resolve(res)\n      }).catch(err => {\n        this.loading = false\n        this.setResponse(err.response)\n        if (this.http.isCancelError(err)) {\n          this.emit(events.CANCEL)\n        } else {\n          if (err.message && !err.response && err.message.indexOf('timeout') !== -1) {\n            this.emit(events.TIMEOUT)\n          }\n          this.emit(events.ERROR)\n        }\n\n        reject(err)\n      })\n    })\n  }\n\n  reload (force) {\n    return this.fetchDebounced(force)\n  }\n\n  send (params) {\n    return this.fetchDebounced(true, { params })\n  }\n\n  cancel () {\n    this.http.cancel(this)\n  }\n\n  getCacheKey () {\n    if (this.key) return this.key\n    return (typeof window !== 'undefined' && typeof btoa !== 'undefined'\n      ? window.btoa\n      : x => x)(Object.values(this.request).join(':'))\n  }\n\n  getCache () {\n    return this.cache ? this.cache.getItem(this.getCacheKey()) : undefined\n  }\n\n  setCache (value) {\n    this.cache && this.cache.setItem(this.getCacheKey(), value)\n  }\n\n  deleteCache () {\n    this.cache && this.cache.removeItem(this.getCacheKey())\n  }\n\n  setResponse (res) {\n    res = res || {}\n    const isSuccessful = String(res.status).charAt(0) === '2'\n    this.status = res.status\n    this.headers = res.headers || {}\n    this.lastLoaded = new Date()\n    this.data = isSuccessful ? this.responseTransformer(res.data, this) : null\n    this.error = !isSuccessful ? this.errorTransformer(res.data, this) : null\n  }\n\n  startInterval (ms) {\n    /* istanbul ignore if */\n    if (typeof ms !== 'number') throw new Error('[Chimera]: interval should be number')\n    /* istanbul ignore if */\n    if (typeof process !== 'undefined' && process.server) return\n\n    this._interval = ms\n    this.stopInterval()\n    this._interval_id = setInterval(() => this.reload(true), this._interval)\n  }\n\n  stopInterval () {\n    if (this._interval_id) {\n      clearInterval(this._interval_id)\n      this._interval_id = null\n      this._interval = false\n    }\n  }\n\n  get looping () {\n    return !!this._interval\n  }\n\n  get request () {\n    return mergeExistingKeys(INITIAL_REQUEST, this, {\n      baseURL: this.baseURL,\n      timeout: this.timeout,\n      headers: this.headers\n    })\n  }\n\n  get response () {\n    return mergeExistingKeys(INITIAL_RESPONSE, this)\n  }\n\n  toString () {\n    return JSON.stringify(this.response)\n  }\n}\n","import Endpoint from './Endpoint'\n\nexport default class NullEndpoint extends Endpoint {\n\n  constructor () {\n    super({})\n  }\n\n  fetch (force) {\n    return Promise.reject(new Error('[Chimera]: Fetching null endpoint'))\n  }\n\n  cancel () {}\n}\n","import Endpoint from './Endpoint'\nimport NullEndpoint from './NullEndpoint'\nimport { hasKey, isPlainObject, getServerContext, warn } from './utils'\n\nconst shouldAutoFetch = r => r.auto && (!r.prefetched || r.prefetch === 'override')\n\nexport default class VueChimera {\n  constructor (vm, { ...endpoints }, { deep, ssrContext, ...options }) {\n    this._vm = vm\n    this._watchers = []\n\n    this.LocalEndpoint = class extends Endpoint {}\n    Object.assign(this.LocalEndpoint.prototype, options)\n\n    this._deep = deep\n    this._ssrContext = getServerContext(ssrContext)\n    this._server = vm.$isServer\n    const watchOption = {\n      immediate: true,\n      deep: this._deep,\n      sync: true\n    }\n\n    for (let key in endpoints) {\n      if (key.charAt(0) === '$') {\n        delete endpoints[key]\n        continue\n      }\n\n      let r = endpoints[key]\n      if (typeof r === 'function') {\n        this._watchers.push([\n          () => r.call(this._vm),\n          (t, f) => this.updateEndpoint(key, t, f),\n          watchOption\n        ])\n      } else {\n        r = endpoints[key] = this.endpointFrom(r)\n        if (!this._server) {\n          shouldAutoFetch(r) && r.reload()\n        }\n      }\n    }\n\n    Object.defineProperty(endpoints, '$cancelAll', { value: () => this.cancelAll() })\n    Object.defineProperty(endpoints, '$loading', { get () { return !!Object.values(this).find(el => !!el.loading) } })\n    this.endpoints = endpoints\n\n    // Init computeds\n    const vmOptions = this._vm.$options\n    const computeds = vmOptions.computed = vmOptions.computed || {}\n    Object.keys(endpoints).forEach(key => {\n      if (hasKey(computeds, key) || hasKey(vmOptions.props, key) || hasKey(vmOptions.methods, key)) return\n      computeds[key] = () => this.endpoints[key]\n    })\n  }\n\n  init () {\n    this._watchers = this._watchers.map(w => this._vm.$watch(...w))\n  }\n\n  initServer () {\n    this._vm.$_chimeraPromises = []\n    Object.values(this.endpoints).forEach(endpoint => {\n      if (endpoint.prefetch) {\n        if (!endpoint.key) {\n          warn('used prefetch with no key associated with endpoint!')\n          return\n        }\n        this._vm.$_chimeraPromises.push(endpoint.fetch(true, { timeout: endpoint.prefetchTimeout }).then(() => endpoint).catch(() => null))\n      }\n    })\n  }\n\n  updateEndpoint (key, newValue, oldValue) {\n    const oldEndpoint = this.endpoints[key]\n    const newEndpoint = this.endpointFrom(newValue, oldValue && oldValue.keepData ? oldEndpoint.toObj() : null)\n\n    if (oldValue && oldEndpoint) {\n      oldEndpoint.stopInterval()\n      newEndpoint.lastLoaded = oldEndpoint.lastLoaded\n    }\n\n    if (!this._server) {\n      if (shouldAutoFetch(newEndpoint)) newEndpoint.reload()\n    }\n    this._vm.$set(this.endpoints, key, newEndpoint)\n  }\n\n  endpointFrom (value, initial) {\n    if (value == null) return new NullEndpoint()\n    if (typeof value === 'string') value = { url: value }\n\n    if (isPlainObject(value.on)) {\n      Object.entries(value.on).forEach(([event, handler]) => {\n        if (typeof handler === 'function') {\n          handler = handler.bind(this._vm)\n        }\n        if (typeof handler === 'string') handler = this._vm[handler]\n        value.on[event] = handler\n      })\n    }\n\n    const endpoint = new this.LocalEndpoint(value, initial)\n\n    if (!this._server && !initial && endpoint.key && endpoint.prefetch && this._ssrContext) {\n      initial = this._ssrContext[value.key]\n      if (initial) initial.prefetched = true\n      Object.assign(endpoint, initial)\n    }\n    return endpoint\n  }\n\n  cancelAll () {\n    Object.values(this.endpoints).forEach(r => {\n      r.cancel()\n    })\n  }\n\n  destroy () {\n    const vm = this._vm\n\n    this.cancelAll()\n    Object.values(this.endpoints).forEach(r => {\n      r.stopInterval()\n    })\n    delete vm._chimera\n  }\n}\n","import VueChimera from './VueChimera'\nimport { isPlainObject } from './utils'\n\nexport default (options = {}) => ({\n  beforeCreate () {\n    const vmOptions = this.$options\n    let chimera\n\n    // Stop if instance doesn't have chimera or already initialized\n    /* istanbul ignore if */\n    if (!vmOptions.chimera || vmOptions._chimera) return\n\n    if (typeof vmOptions.chimera === 'function') {\n      // Initialize with function\n      vmOptions.chimera = vmOptions.chimera.call(this)\n    }\n    /* istanbul ignore else */\n    if (isPlainObject(vmOptions.chimera)) {\n      const { $options, ...endpoints } = vmOptions.chimera\n      chimera = new VueChimera(this, endpoints, { ...options, ...$options })\n    } else {\n      throw new Error('[Chimera]: chimera options should be an object or a function that returns object')\n    }\n\n    this._chimera = chimera\n    if (!Object.prototype.hasOwnProperty.call(this, '$chimera')) {\n      Object.defineProperty(this, '$chimera', {\n        get: () => chimera.endpoints\n      })\n    }\n  },\n\n  data () {\n    /* istanbul ignore if */\n    if (!this._chimera) return {}\n    return {\n      $chimera: this._chimera.endpoints\n    }\n  },\n\n  created () {\n    /* istanbul ignore if */\n    if (!this._chimera) return\n    this._chimera.init()\n    this.$isServer && this._chimera.initServer()\n  },\n\n  beforeDestroy () {\n    /* istanbul ignore if */\n    if (!this._chimera) return\n    this._chimera.destroy()\n  },\n\n  serverPrefetch (...args) {\n    /* istanbul ignore if */\n    if (!this.$_chimeraPromises) return\n    const ChimeraSSR = require('../ssr/index')\n    return Promise.all(this.$_chimeraPromises).then(results => {\n      results.forEach(endpoint => {\n        endpoint && ChimeraSSR.addEndpoint(endpoint)\n      })\n    })\n  }\n})\n","<script>\nimport NullEndpoint from \"../NullEndpoint\";\nimport Endpoint from \"../Endpoint\";\nimport * as events from \"../events\"\nimport { getServerContext } from \"../utils\";\n\nexport default {\n\n    inheritAttrs: false,\n\n    props: {\n        options: {\n            type: [Object, String],\n            required: true,\n        },\n        tag: {\n            type: String,\n            default: null,\n        }\n    },\n\n    data () {\n        return {\n            endpoint: this.getEndpoint()\n        }\n    },\n\n    beforeCreate() {\n        this._ssrContext = getServerContext(this.$chimeraOptions.ssrContext)\n    },\n\n    render (h) {\n        let result = this.$scopedSlots.default(this.endpoint)\n        if (Array.isArray(result)) {\n            result = result.concat(this.$slots.default)\n        } else {\n            result = [result].concat(this.$slots.default)\n        }\n        return this.tag ? h(this.tag, result) : result[0]\n    },\n\n    created () {\n        const ep = this.endpoint\n        if (this.$isServer && ep.key) {\n            this.$_chimeraPromises = [ep.fetch(true).then(() => ep).catch(() => null)]\n        }\n    },\n\n    mounted () {\n        const ep = this.endpoint\n        if (ep.auto && (!ep.data || ep.prefetch === 'override')) {\n            ep.reload()\n        }\n    },\n\n    methods: {\n        getEndpoint () {\n            let value = this.options\n            if (value == null) return new NullEndpoint()\n            if (typeof value === 'string') value = { url: value }\n\n            const endpoint = new Endpoint({\n                ...this.$chimeraOptions,\n                ...value,\n            })\n\n            Object.values(events).forEach(ev => {\n                endpoint.on(ev, () => this.$emit(ev, endpoint))\n            })\n\n            if (!this._server && endpoint.key && endpoint.prefetch && this._ssrContext) {\n                const initial = this._ssrContext[endpoint.key]\n                if (initial) initial.prefetched = true\n                Object.assign(endpoint, initial)\n            }\n\n            return endpoint\n        }\n    }\n\n}\n</script>\n","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","export class MemoryCache {\n  constructor (expiration) {\n    this.expiration = expiration || 1000 * 60\n    this._store = {}\n  }\n\n  /**\n     *\n     * @param key         Key for the cache\n     * @param value       Value for cache persistence\n     * @param expiration  Expiration time in milliseconds\n     */\n  setItem (key, value, expiration) {\n    this._store[key] = {\n      expiration: Date.now() + (expiration || this.expiration),\n      value\n    }\n  }\n\n  /**\n     * If Cache exists return the Parsed Value, If Not returns {null}\n     *\n     * @param key\n     */\n  getItem (key) {\n    let item = this._store[key]\n\n    if (item && item.value && Date.now() <= item.expiration) {\n      return item.value\n    }\n\n    this.removeItem(key)\n    return null\n  }\n\n  removeItem (key) {\n    delete this._store[key]\n  }\n\n  keys () {\n    return Object.keys(this._store)\n  }\n\n  all () {\n    return this.keys().reduce((obj, str) => {\n      obj[str] = this._store[str]\n      return obj\n    }, {})\n  }\n\n  length () {\n    return this.keys().length\n  }\n\n  clear () {\n    this._store = {}\n  }\n}\n","import mixin from './mixin'\nimport ChimeraEndpoint from './components/ChimeraEndpoint.vue'\nimport Endpoint from './Endpoint'\nimport { mergeExistingKeys } from './utils'\n\nconst plugin = {\n\n  options: {\n    baseURL: null,\n    cache: null,\n    debounce: 50,\n    deep: true,\n    keepData: true,\n    auto: 'get', // false, true, '%METHOD%',\n    prefetch: null,\n    prefetchTimeout: 4000,\n    transformer: null,\n    ssrContext: null\n  },\n\n  install (Vue, options = {}) {\n    options = mergeExistingKeys(this.options, options)\n\n    Vue.mixin(mixin(options))\n    Vue.component('chimera-endpoint', ChimeraEndpoint)\n    Vue.prototype.$chimeraOptions = options\n\n    const { deep, ssrContext, ...endpointOptions } = options\n    Object.assign(Endpoint.prototype, endpointOptions)\n  }\n\n}\n\n// Auto-install\nlet GlobalVue = null\n/* istanbul ignore if */\n/* istanbul ignore else */\nif (typeof window !== 'undefined') {\n  GlobalVue = window.Vue\n} else if (typeof global !== 'undefined') {\n  GlobalVue = global.Vue\n}\n\n/* istanbul ignore if */\nif (GlobalVue) {\n  GlobalVue.use(plugin, plugin.options)\n}\n\nexport default plugin\n\nexport * from './events'\nexport { StorageCache } from './cache/StorageCache'\nexport { MemoryCache } from './cache/MemoryCache'\n","import { MemoryCache } from './MemoryCache'\n\nexport class StorageCache extends MemoryCache {\n  constructor (key, expiration, sessionStorage = false) {\n    super(expiration)\n    this.key = key\n\n    const storage = sessionStorage ? 'sessionStorage' : 'localStorage'\n    /* istanbul ignore if */\n    if (typeof window === 'undefined' || !window[storage]) {\n      throw Error(`StorageCache: ${storage} is not available.`)\n    } else {\n      this.storage = window[storage]\n    }\n\n    try {\n      this._store = JSON.parse(this.storage.getItem(key)) || {}\n    } catch (e) {\n      this.clear()\n      this._store = {}\n    }\n  }\n\n  setItem (key, value, expiration) {\n    super.setItem(key, value, expiration)\n    this.storage.setItem(this.key, JSON.stringify(this._store))\n  }\n\n  clear () {\n    this.storage.removeItem(this.key)\n  }\n}\n"],"names":["fn","wait","opts","Number","isFinite","TypeError","leadingVal","timer","resolveList","ctx","this","args","arguments","Promise","resolve","runImmediately","leading","clearTimeout","setTimeout","res","apply","push","SUCCESS","ERROR","CANCEL","LOADING","TIMEOUT","isPlainObject","value","Object","prototype","toString","mergeExistingKeys","obj","o","assign","keys","reduce","carry","item","hasKey","key","getServerContext","contextString","context","window","split","forEach","e","noopReturn","arg","warn","console","request","endpoint","config","axios","Axios","create","cancelToken","CancelToken","c","_canceler","cancel","isCancelError","err","isCancel","INITIAL_RESPONSE","status","data","headers","error","lastLoaded","INITIAL_REQUEST","url","baseURL","method","params","timeout","Endpoint","constructor","initial","Error","debounce","transformer","interval","on","listeners","options","toLowerCase","fetchDebounced","pDebounce","fetch","bind","setTransformer","prefetched","loading","auto","Boolean","prefetch","http","axiosAdapter","startInterval","responseTransformer","errorTransformer","response","event","handler","emit","force","extraOptions","reject","cache","cacheValue","getCache","setResponse","events","then","setCache","catch","message","indexOf","reload","send","getCacheKey","btoa","x","values","join","getItem","undefined","setItem","deleteCache","removeItem","isSuccessful","String","charAt","Date","ms","process","server","_interval","stopInterval","_interval_id","setInterval","clearInterval","JSON","stringify","NullEndpoint","shouldAutoFetch","r","VueChimera","vm","endpoints","deep","ssrContext","_vm","_watchers","LocalEndpoint","_deep","_ssrContext","_server","$isServer","watchOption","immediate","sync","call","t","f","updateEndpoint","endpointFrom","defineProperty","cancelAll","get","find","el","vmOptions","$options","computeds","computed","props","methods","init","map","w","$watch","initServer","$_chimeraPromises","prefetchTimeout","newValue","oldValue","oldEndpoint","newEndpoint","keepData","toObj","$set","entries","destroy","_chimera","beforeCreate","chimera","hasOwnProperty","$chimera","created","beforeDestroy","serverPrefetch","ChimeraSSR","require","all","results","addEndpoint","template","style","script","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","hook","render","staticRenderFns","_compiled","functional","_scopeId","$vnode","parent","__VUE_SSR_CONTEXT__","_registeredComponents","add","_ssrRegister","$root","shadowRoot","originalRender","h","existing","concat","MemoryCache","expiration","_store","now","str","length","clear","plugin","install","Vue","mixin","component","ChimeraEndpoint","$chimeraOptions","endpointOptions","GlobalVue","global","use","sessionStorage","storage","parse"],"mappings":"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"}